\documentclass[12pt]{article}

\usepackage[a4paper,left=2.5cm,right=2.5cm,top=1.5cm,bottom=2.5cm]{geometry}

% \usepackage{amsmath}
% \usepackage{amssymb}
% \usepackage{caption}
% \captionsetup{justification=centering}
% \usepackage{subcaption}
\usepackage{hyperref} % for href
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}

% \usepackage{ragged2e} % for flushleft

\usepackage[table]{xcolor} % Required for \cellcolor

\setlength{\parindent}{0pt} % don't paragraphs by default

\title{\textbf{i281 CPU} \\
A Course Project for EE224 Digital Systems}

\author{
  Team Name: \textbf{googoogaga} \\
  Team Members: \\
  Visharad Srivastava (24B1202) \\
  Shridhar Patil (24B1261) \\
  Jai Bellare (24B1307)
}

\date{Submission Date: \textbf{23 November, 2025}}

\begin{document}

\maketitle

\vspace{2cm}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{01_quartus_netlist.png}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{02_bubble_sort_waveform.png}
\end{figure}

\newpage

\tableofcontents

\newpage

\section{Introduction}

In this report, we present our design, Verilog implementation, and simulation of the i281, an 8-bit CPU. This CPU was made for the course project of EE224 Digital Systems at IIT Bombay, instructed by Prof. Sachin Patkar.
We follow the work of \href{https://www.ece.iastate.edu/~alexs/classes/2024_Fall_2810/}{Prof. Alexander Stoytchev} and his group at Iowa State University.

Find the Verilog code, waveforms and documentation at \url{https://github.com/jjbel/i281_cpu}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{01_quartus_netlist.png}
  \caption{Netlist of the CPU}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{02_bubble_sort_waveform.png}
  \caption{Bubble Sort Waveform}
\end{figure}

Below we explain the architecture and design choices, followed by a demo of running the bubble sort algorithm.

\section{Architecture}

\subsection{Overview}

The CPU is of the Harvard-style architecture, with separate cod (64x 16-bit) and data (16x 8-bit) memories.

The CPU is single-cycle, with a purely combinational control logic block. There are 26 assembly instructions, which map to 23 Opcodes. The control logic block converts the decoded opcode to 18 control signals c1 to c18.

The ALU supports addition, subtraction, left and right bitshifts. It operates on 4x 6-bit registers A,B,C,D.

\pagebreak

\begin{center}
  \includegraphics[width=\textwidth]{03_architecture_block_diagram.png}
\end{center}

Drawing conventions: inputs enter from the left, outputs exit from the right, control lines are vertical arrows on the top.

\subsection{Memories}

\begin{enumerate}
  \item \textbf{Code Memory} : 64 rows of 16-bit registers, hence a 6-bit Program Counter (PC)
  \item \textbf{Data Memory} : 16 rows of 8-bit registers
\end{enumerate}

The 6-bit program counter specifies the current instruction.

\pagebreak

\subsection{Instructions and Opcode Decoder}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{04_instructions.png}
  \caption{Assembly Instructions}
\end{figure}

There are 26 assembly instructions, which map to 23 Opcodes. LOADI/LOADP, BRE/BRZ and BRNE/BRNZ are aliased.

The decoder produces 27 outputs: a 23-bit one-hot opcode, and 4 outputs to select registers A,B,C or D.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{decoder_netlist.png}
  \caption{Opcode Decoder Diagram}
\end{figure}

Each 16-bit register of the code memory encodes an instruction:
\begin{enumerate}
  \item instr[15:12] majorly chooses the instruction, using a 4-to-16 decoder which produces a one-hot output
  \item instr[11:10] further choose which register A,B,C or D to use for the first operand
  \item instr[9:8] either choose which register to use for the second operand, or which of (INPUTC, INPUTCF, INPUTD, INPUTDF), or of (BRE/BRZ, BRNE/BRNZ, BRG, BRGE)
  \item instr[8] also decides whether to shift left or right
  \item The lower byte instr[7:0] is NOT routed through the decoder. It is either an 8-bit immediate value, or a 6-bit address for data memory or branching
\end{enumerate}

Immediate values allow using compile-time constants for loading into registers, or for arithmetic operations.

Jumps specify a fixed 6-bit relative-jump to unconditionally move the program counter by. Branches allow conditionally jumping based on comparisons from the flags output of the ALU. Jumps and branches are necessary for control flow like if/else statements and loops.

\subsection{Control Logic}

Since the CPU is single-cycle, the control logic block is purely combinational. The control logic block maps the 27-bit opcode decoder output to 18 control signals c1 to c18.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{05_control_signal_output_table.png}
  \caption{Control Signal Output Table}
\end{figure}

The Control Signal Output Table specifies what outputs (C1 to c18) a given decoded opcode produces.
For example, the ADD instruction:
\begin{enumerate}
  \item specifies the operands in $c_4c_5$ and $c_6c_7$
  \item sets $c_{10}$ to route the ALU output to the destination register
  \item and chooses the ALU's addition operation in $c_{11}c_{12}$
\end{enumerate}

% TODO could describe each control signal here

\subsection{ALU and Registers}

The ALU supports 4 operations:
\begin{enumerate}
  \item left shift (SHIFTL)
  \item right shift (SHIFTR)
  \item add (ADD)
  \item subtract (SUB)
\end{enumerate}

The ALU operates on 4x 8-bit registers: A,B,C,D.

\section{Verilog implementation}

Find the Verilog code, waveforms and documentation at \url{https://github.com/jjbel/i281_cpu}

We implemented each block in a separate Verilog module. For example the folder \texttt{i281\_main/Control Logic} contains the control logic in \texttt{controllogic.v}, its testbench in \texttt{controllogic\_tb.v}.

\subsection{Directory structure}

\begin{verbatim}
i281_main
|   dump.vcd
|   i281_main.qpf
|   i281_main.qsf
|   i281_toplevel.v
|   i281_toplevel_tb.v
---ALU
|   |   alu.v
|   |   alu_tb.v
---Assembler
|   |   BIOS_Hardcoded_High.v
|   |   BIOS_Hardcoded_Low.v
|   |   BubbleSort.asm
|   |   i281assembler.java
|   |   User_Code_High.v
|   |   User_Code_Low.v
|   |   User_Data.v
---Code Memory
|       codemem.v
---Control Logic
|   |   a.out
|   |   controllogic.v
|   |   controllogic_tb.v
---Data Memory
|       datamem.v
---Flags
|       flags.v
---OpCode Decoder
|   |   opcodedec.v
|   |   opcodedec_tb.v
---PC
|       pc.v
---PC Update
|       a.out
|       pc_update.v
|       pc_update_slide.png
|       pc_update_tb.v
---Registers
|       registers.v

\end{verbatim}

\section{Assembler}

We use Prof. Stoytchev's assembler \texttt{i281assembler.java} to convert assembly code in a .asm file to machine code. It produces 4 verilog files: BIOS\_Hardcoded\_High.v and BIOS\_Hardcoded\_Low.v have an empty BIOS which just jumps to the user code at row 32. The user code is in User\_Code\_Low.v and User\_Code\_High.v. For example, this stores the bubble sort code. Finally, we give the input numbers to the bubble sort in User\_Data.v. The codemem and datamem Verilog modules instantiate modules to load these hardcoded values on reset.

\section{Running Bubble Sort, Memory Waveforms}

Following is the contents of the data memory, registers, and flags while bubble sort is running. The array (7,3,2,1,6,4,5,8) is finally sorted in ascending order.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{bubble_waveform_flags.png}
  \caption{Bubble Sort Waveform}
\end{figure}

\newpage
\section{Multi-cycle Implementation}

The Multicycle Implementation of i281 CPU requires us to create an FSM control block which generates a different FSM for each instruction. Since we are to use the same assembler, the Opcode decoder is kept the same.

\begin{figure} [H]
  \centering
  \includegraphics[width=0.9\linewidth]{Multicycle Datapath.png}
  \caption{Datapath Diagram}
  \label{fig:placeholder}
\end{figure}

A fixed set of states is first created, each of which has a definite output sequence of c[24:1]. Each instruction will be a FSM of a subset of these states. The set of states used is provided below:

\lstdefinestyle{verilog_dark}{
  backgroundcolor=\color{black!5},
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue!70}\bfseries,
  commentstyle=\color{green!40!black},
  stringstyle=\color{red!70},
  numbers=left,
  numberstyle=\tiny\color{gray!60},
  frame=single,
  rulecolor=\color{black!50},
  breaklines=true,
  xleftmargin=10pt,
  xrightmargin=10pt
}

\begin{lstlisting}[style=verilog_dark, language=Verilog]
localparam IF        = 5'd0,
           ID        = 5'd1,
           ExALU     = 5'd2,
           ExADDR    = 5'd3,
           ExBRANCH  = 5'd4,
           ExJUMP    = 5'd5,
           MemREAD   = 5'd6,
           MemWRITE  = 5'd7,
           WbALU     = 5'd8,
           WbLOAD    = 5'd9,
           ExLOAD    = 5'd10,
           ExLOADI   = 5'd11,
           ExLIR     = 5'd12,
           ExMOVE    = 5'd13,
           ExSWAPREG = 5'd14;
\end{lstlisting}

\newpage
A basic representation of the control logic FSM is as follows:

\begin{lstlisting}[style=verilog_dark, language=Verilog]
module controlfsm (...)
    always@(posedge clock or posedge reset)
    if(reset) begin
        state <= IF;
    end
    else begin
        state <= next_state
    end

    always@(*) begin
        case(opcode[22:0])
            instruction = f(opcode_in)
        endcase
    end

    always@(*) begin
        next_state = g(state,instruction)
    end

    always@(*) begin
        case(state)
            c(I)
        endcase
    end

endmodule
\end{lstlisting}

For example, a NOOP command will cycle from IF (Instruction fetch) to ID (Instruction Decode) and back to IF (instruction fetch), where the next instruction is run.

\begin{lstlisting}[style=verilog_dark, language=Verilog]
  casez ({
      state, instruction
    })
      {
        IF, 5'bzzzzz  //instruction is reg[4:0], any instruction has next ID
      } : begin
        next_state = ID;
      end
      // NOOP OPERATION
      {
        ID, 5'd0
      } : begin
        next_state = IF;
      end
\end{lstlisting}

\subsubsection{Brief Description of Important States:}
\begin{itemize}
  \item IF: (Instruction Fetch): Next instruction is fetched into the IMEM Register. PC and value 8'b00000001 are loaded into ALU operands and addition is done to calculate PC + 1 (the default next address to read from). (This is a difference to single-cycle variant where PC what updated with a separate adder)
  \item ID: Instruction decode: Here values of register[RX], register [RY] are loaded into left input reg and right input reg for calculations. The instruction is decoded from the opcode provided using a binary decoder as opcode\_in[22:0] are one-hot encoded.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{waveform_RTL.png}
  \caption{RTL view of the datapath, in Quartus}
  \label{fig:placeholder}
\end{figure}

\end{document}
